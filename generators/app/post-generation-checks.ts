/**
 * Module de v√©rifications post-g√©n√©ration pour Spring-Fullstack-Speed
 * Ce module contient des fonctions pour valider l'int√©grit√© du projet apr√®s g√©n√©ration
 */

import chalk from "chalk";
import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

// Convertir exec en Promise
const execAsync = promisify(exec);

/**
 * Interface pour les r√©sultats de v√©rification
 */
interface CheckResult {
  success: boolean;
  missingFiles: string[];
  errors: string[];
  warnings: string[];
  suggestions: string[];
}

/**
 * Liste des fichiers essentiels qui devraient √™tre pr√©sents dans tout projet Spring Boot
 * @param templateData Donn√©es du mod√®le utilis√© pour la g√©n√©ration
 * @returns string[] Liste des fichiers essentiels
 */
function getEssentialFiles(templateData: any): string[] {
  const files:any = [];
  const buildTool = templateData.buildTool?.toLowerCase() || 'maven';
  const packagePath = templateData.javaPackagePath || templateData.packageName?.replace(/\./g, '/') || 'com/example';
  const mainPath = `src/main/java/${packagePath}`;
  const className = templateData.appName
    .split("-")
    .map((part: string) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");

  // Fichier principal de build
  if (buildTool === 'maven') {
    files.push('pom.xml');
    files.push('mvnw');
    files.push('mvnw.cmd');
  } else {
    files.push('build.gradle.kts');
    files.push('settings.gradle.kts');
    files.push('gradlew');
    files.push('gradlew.bat');
  }

  // Fichiers de l'application
  files.push(`${mainPath}/${className}Application.java`);
  files.push('src/main/resources/application.properties');
  files.push('src/main/resources/application-dev.properties');
  files.push('src/main/resources/application-prod.properties');
  files.push('.gitignore');
  files.push('README.md');

  // Docker
  files.push('Dockerfile');
  files.push('docker-compose.yml');

  // Si un frontend est configur√©
  if (templateData.frontendFramework !== 'Aucun (API seulement)') {
    files.push('frontend/package.json');
    if (templateData.frontendFramework.includes('React')) {
      files.push('frontend/vite.config.ts');
      files.push('frontend/src/App.tsx');
    } else if (templateData.frontendFramework.includes('Vue')) {
      files.push('frontend/vite.config.ts');
      files.push('frontend/src/App.vue');
      files.push('frontend/src/main.ts');
    } else if (templateData.frontendFramework.includes('Angular')) {
      files.push('frontend/angular.json');
      files.push('frontend/src/app/app.component.ts');
    }
  }

  // Fichiers sp√©cifiques √† l'authentification
  if (templateData.includeAuth) {
    if (templateData.authType === 'JWT') {
      files.push(`${mainPath}/security/config/WebSecurityConfig.java`);
      files.push(`${mainPath}/security/model/User.java`);
      files.push(`${mainPath}/security/model/Role.java`);
      files.push(`${mainPath}/security/service/JwtUtils.java`);
    }
  }

  // Kubernetes
  if (templateData.kubernetes) {
    files.push('kubernetes/README.md');

    if (templateData.kubernetes.deploymentType === 'raw-manifests') {
      files.push(`kubernetes/deployments/${templateData.appName}-deployment.yaml`);
      files.push(`kubernetes/services/${templateData.appName}-service.yaml`);
    } else if (templateData.kubernetes.deploymentType === 'helm') {
      files.push(`kubernetes/helm/${templateData.appName}/Chart.yaml`);
      files.push(`kubernetes/helm/${templateData.appName}/values.yaml`);
    }
  }

  return files;
}

/**
 * V√©rifie l'existence des fichiers essentiels dans le projet g√©n√©r√©
 * @param generator R√©f√©rence au g√©n√©rateur
 * @param templateData Donn√©es du template utilis√©
 * @returns CheckResult R√©sultats de la v√©rification
 */
export function verifyProjectIntegrity(generator: any, templateData: any): CheckResult {
  generator.log(chalk.blue("üîç V√©rification de l'int√©grit√© du projet g√©n√©r√©..."));

  const result: CheckResult = {
    success: true,
    missingFiles: [],
    errors: [],
    warnings: [],
    suggestions: []
  };

  // R√©cup√©rer la liste des fichiers essentiels
  const essentialFiles = getEssentialFiles(templateData);

  // V√©rifier l'existence de chaque fichier essentiel
  for (const file of essentialFiles) {
    const filePath = generator.destinationPath(file);
    if (!fs.existsSync(filePath)) {
      result.success = false;
      result.missingFiles.push(file);
    }
  }

  // V√©rifier les permissions d'ex√©cution des scripts
  checkExecutablePermissions(generator, templateData, result);

  // Si frontend, v√©rifier package.json
  if (templateData.frontendFramework !== 'Aucun (API seulement)') {
    checkPackageJsonIntegrity(generator, templateData, result);
  }

  return result;
}

/**
 * V√©rifie les permissions d'ex√©cution des scripts
 */
function checkExecutablePermissions(generator: any, templateData: any, result: CheckResult): void {
  if (process.platform === 'win32') {
    // Windows ne g√®re pas les permissions comme Unix
    return;
  }

  const scriptsToCheck:any = [];
  if (templateData.buildTool.toLowerCase() === 'maven') {
    scriptsToCheck.push('mvnw');
  } else {
    scriptsToCheck.push('gradlew');
  }

  for (const script of scriptsToCheck) {
    const scriptPath = generator.destinationPath(script);
    if (fs.existsSync(scriptPath)) {
      try {
        const stats = fs.statSync(scriptPath);
        const isExecutable = !!(stats.mode & 0o111); // V√©rifie si le mode inclut des permissions d'ex√©cution

        if (!isExecutable) {
          result.warnings.push(`Le script ${script} n'a pas les permissions d'ex√©cution.`);
          // Correction automatique
          try {
            fs.chmodSync(scriptPath, '755');
            result.suggestions.push(`Les permissions d'ex√©cution ont √©t√© ajout√©es √† ${script}.`);
          } catch (err) {
            result.errors.push(`Impossible d'ajouter des permissions d'ex√©cution √† ${script}: ${err}`);
          }
        }
      } catch (err) {
        result.errors.push(`Erreur lors de la v√©rification des permissions de ${script}: ${err}`);
      }
    }
  }
}

/**
 * V√©rifie l'int√©grit√© du package.json pour le frontend
 */
function checkPackageJsonIntegrity(generator: any, templateData: any, result: CheckResult): void {
  const packageJsonPath = generator.destinationPath('frontend/package.json');
  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

      // V√©rifier les d√©pendances essentielles selon le framework
      const framework = templateData.frontendFramework;
      const missingDeps:any = [];

      if (framework.includes('React')) {
        if (!packageJson.dependencies.react) missingDeps.push('react');
        if (!packageJson.dependencies['react-dom']) missingDeps.push('react-dom');
      } else if (framework.includes('Vue')) {
        if (!packageJson.dependencies.vue) missingDeps.push('vue');
        if (!packageJson.dependencies['vue-router']) missingDeps.push('vue-router');
      } else if (framework.includes('Angular')) {
        if (!packageJson.dependencies['@angular/core']) missingDeps.push('@angular/core');
      }

      if (missingDeps.length > 0) {
        result.warnings.push(`Le fichier package.json ne contient pas toutes les d√©pendances n√©cessaires pour ${framework}: ${missingDeps.join(', ')}`);
      }

      // V√©rifiez que les scripts essentiels sont pr√©sents
      const requiredScripts = ['dev', 'build', 'preview'];
      const missingScripts = requiredScripts.filter(script => !packageJson.scripts[script]);

      if (missingScripts.length > 0) {
        result.warnings.push(`Le fichier package.json ne contient pas tous les scripts n√©cessaires: ${missingScripts.join(', ')}`);
      }
    } catch (err) {
      result.errors.push(`Erreur lors de l'analyse du package.json: ${err}`);
    }
  }
}

/**
 * Installe les d√©pendances NPM pour le frontend si n√©cessaire
 * @param generator R√©f√©rence au g√©n√©rateur
 * @param templateData Donn√©es du template utilis√©
 */
export async function installFrontendDependencies(generator: any, templateData: any): Promise<{success: boolean, error?: string}> {
  if (templateData.frontendFramework === 'Aucun (API seulement)') {
    return { success: true };
  }

  generator.log(chalk.blue("üì¶ Installation des d√©pendances frontend..."));

  const frontendDir = generator.destinationPath('frontend');
  const packageJsonPath = path.join(frontendDir, 'package.json');

  // V√©rifier si package.json existe
  if (!fs.existsSync(packageJsonPath)) {
    return {
      success: false,
      error: "Le fichier package.json n'a pas √©t√© trouv√©. Les d√©pendances frontend ne peuvent pas √™tre install√©es."
    };
  }

  try {
    // D√©terminer le gestionnaire de paquets √† utiliser (npm ou yarn)
    let packageManager = 'npm';
    // Tester si yarn est disponible
    try {
      await execAsync('yarn --version', { cwd: frontendDir });
      packageManager = 'yarn';
    } catch (e) {
      // Yarn n'est pas disponible, on utilise npm par d√©faut
    }

    generator.log(chalk.yellow(`Utilisation de ${packageManager} pour installer les d√©pendances...`));

    // Commande d'installation
    const installCommand = packageManager === 'yarn' ? 'yarn install' : 'npm install';

    // Ex√©cuter la commande d'installation
    generator.log(chalk.yellow(`Ex√©cution de: ${installCommand} dans ${frontendDir}`));
    await execAsync(installCommand, { cwd: frontendDir });

    generator.log(chalk.green("‚úÖ Installation des d√©pendances frontend termin√©e avec succ√®s."));
    return { success: true };
  } catch (error) {
    const errorMessage = `Erreur lors de l'installation des d√©pendances frontend: ${error}`;
    generator.log(chalk.red(`‚ùå ${errorMessage}`));

    // Suggestions de r√©solution
    generator.log(chalk.yellow("\nSuggestions de r√©solution:"));
    generator.log(chalk.yellow("1. V√©rifiez votre connexion internet"));
    generator.log(chalk.yellow("2. Assurez-vous que npm ou yarn est correctement install√©"));
    generator.log(chalk.yellow("3. Essayez d'installer manuellement les d√©pendances:"));
    generator.log(chalk.yellow(`   - cd ${frontendDir}`));
    generator.log(chalk.yellow("   - npm install"));

    return { success: false, error: errorMessage };
  }
}

/**
 * V√©rifie les versions des outils requis (Node.js, Java, etc.)
 */
export async function checkToolVersions(generator: any): Promise<{success: boolean, messages: string[]}> {
  generator.log(chalk.blue("üîç V√©rification des versions des outils requis..."));

  const messages: string[] = [];
  let success = true;

  try {
    // V√©rifier Node.js
    const nodeResult = await execAsync('node --version');
    const nodeVersion = nodeResult.stdout.trim();
    const nodeVersionNum = parseFloat(nodeVersion.replace('v', ''));

    if (nodeVersionNum < 14) {
      messages.push(chalk.red(`‚ö†Ô∏è Votre version de Node.js (${nodeVersion}) est ancienne. Nous recommandons Node.js 14+.`));
      success = false;
    } else {
      messages.push(chalk.green(`‚úÖ Node.js ${nodeVersion} d√©tect√©.`));
    }

    // V√©rifier npm
    const npmResult = await execAsync('npm --version');
    const npmVersion = npmResult.stdout.trim();
    messages.push(chalk.green(`‚úÖ npm ${npmVersion} d√©tect√©.`));

    // V√©rifier Java si possible
    try {
      const javaResult = await execAsync('java -version 2>&1');
      // java -version √©crit sur stderr, pas stdout
      const javaVersionOutput = javaResult.stderr || javaResult.stdout;
      const javaVersionMatch = javaVersionOutput.match(/"(\d+\.\d+).*"/);

      if (javaVersionMatch) {
        const javaVersion = javaVersionMatch[1];
        const javaVersionNum = parseFloat(javaVersion);

        if (javaVersionNum < 17) {
          messages.push(chalk.yellow(`‚ö†Ô∏è Votre version de Java (${javaVersion}) peut ne pas √™tre compatible. Spring Boot 3 recommande Java 17+.`));
        } else {
          messages.push(chalk.green(`‚úÖ Java ${javaVersion} d√©tect√©.`));
        }
      } else {
        messages.push(chalk.yellow(`‚ö†Ô∏è Version de Java non d√©tect√©e. Assurez-vous que Java est correctement install√©.`));
      }
    } catch (err) {
      messages.push(chalk.yellow("‚ö†Ô∏è Java n'a pas √©t√© d√©tect√© sur votre syst√®me. Vous aurez besoin de Java 17+ pour ex√©cuter votre application Spring Boot."));
    }

    // V√©rifier Maven/Gradle si possible
    try {
      const mvnResult = await execAsync('mvn --version');
      const mvnVersionMatch = mvnResult.stdout.match(/Apache Maven (\d+\.\d+\.\d+)/);
      if (mvnVersionMatch) {
        messages.push(chalk.green(`‚úÖ Maven ${mvnVersionMatch[1]} d√©tect√©.`));
      }
    } catch (err) {
      try {
        const gradleResult = await execAsync('gradle --version');
        const gradleVersionMatch = gradleResult.stdout.match(/Gradle (\d+\.\d+)/);
        if (gradleVersionMatch) {
          messages.push(chalk.green(`‚úÖ Gradle ${gradleVersionMatch[1]} d√©tect√©.`));
        }
      } catch (err2) {
        messages.push(chalk.yellow("‚ö†Ô∏è Ni Maven ni Gradle n'ont √©t√© d√©tect√©s. Vous aurez besoin de l'un d'eux pour construire votre application."));
      }
    }

    // V√©rifier Docker si possible
    try {
      const dockerResult = await execAsync('docker --version');
      const dockerVersion = dockerResult.stdout.trim();
      messages.push(chalk.green(`‚úÖ ${dockerVersion} d√©tect√©.`));
    } catch (err) {
      messages.push(chalk.yellow("‚ö†Ô∏è Docker n'a pas √©t√© d√©tect√©. Vous en aurez besoin pour ex√©cuter les conteneurs Docker."));
    }

  } catch (err) {
    messages.push(chalk.red(`‚ùå Erreur lors de la v√©rification des versions des outils: ${err}`));
    success = false;
  }

  return { success, messages };
}

/**
 * Affiche des conseils finaux et des informations utiles pour l'utilisateur
 */
export function displayFinalInstructions(generator: any, templateData: any, checkResult: CheckResult): void {
  generator.log(chalk.blue("\nüìã R√âSUM√â DE LA G√âN√âRATION DU PROJET"));
  generator.log(chalk.gray("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêÔøΩÔøΩÔøΩ‚ïê"));

  if (checkResult.success) {
    generator.log(chalk.green("‚úÖ Projet g√©n√©r√© avec succ√®s ! Voici quelques √©tapes pour d√©marrer:"));
  } else {
    generator.log(chalk.yellow("‚ö†Ô∏è Le projet a √©t√© g√©n√©r√© mais certains probl√®mes ont √©t√© d√©tect√©s:"));

    if (checkResult.missingFiles.length > 0) {
      generator.log(chalk.yellow("\nFichiers manquants:"));
      checkResult.missingFiles.forEach(file => {
        generator.log(chalk.yellow(`  - ${file}`));
      });
    }

    if (checkResult.errors.length > 0) {
      generator.log(chalk.red("\nErreurs d√©tect√©es:"));
      checkResult.errors.forEach(error => {
        generator.log(chalk.red(`  - ${error}`));
      });
    }

    if (checkResult.warnings.length > 0) {
      generator.log(chalk.yellow("\nAvertissements:"));
      checkResult.warnings.forEach(warning => {
        generator.log(chalk.yellow(`  - ${warning}`));
      });
    }

    generator.log(chalk.yellow("\nVous pouvez tenter de r√©soudre ces probl√®mes avant de continuer."));
  }

  if (checkResult.suggestions.length > 0) {
    generator.log(chalk.cyan("\nSuggestions:"));
    checkResult.suggestions.forEach(suggestion => {
      generator.log(chalk.cyan(`  - ${suggestion}`));
    });
  }

  // Instructions pour d√©marrer l'application
  generator.log(chalk.blue("\nüöÄ POUR D√âMARRER VOTRE APPLICATION"));
  generator.log(chalk.gray("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"));

  // Backend
  generator.log(chalk.cyan("\nBackend (Spring Boot):"));
  if (templateData.buildTool.toLowerCase() === 'maven') {
    generator.log(chalk.white("  cd " + generator.destinationRoot()));
    generator.log(chalk.white("  ./mvnw spring-boot:run"));
  } else {
    generator.log(chalk.white("  cd " + generator.destinationRoot()));
    generator.log(chalk.white("  ./gradlew bootRun"));
  }

  // Frontend
  if (templateData.frontendFramework !== 'Aucun (API seulement)') {
    generator.log(chalk.cyan("\nFrontend (" + templateData.frontendFramework + "):"));
    generator.log(chalk.white("  cd " + path.join(generator.destinationRoot(), 'frontend')));
    generator.log(chalk.white("  npm install    # Si ce n'est pas d√©j√† fait"));
    generator.log(chalk.white("  npm run dev"));
  }

  // Docker
  generator.log(chalk.cyan("\nDocker:"));
  generator.log(chalk.white("  docker-compose up -d"));

  // Kubernetes (si applicable)
  if (templateData.kubernetes) {
    generator.log(chalk.cyan("\nKubernetes:"));
    generator.log(chalk.white("  Consultez le fichier kubernetes/README.md pour les instructions de d√©ploiement"));
  }

  // Acc√®s √† l'application
  generator.log(chalk.blue("\nüåê URL D'ACC√àS:"));
  generator.log(chalk.gray("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêÔøΩÔøΩ‚ïê‚ïê‚ïê‚ïê‚ïê"));
  generator.log(chalk.white("  Backend: http://localhost:8080"));

  if (templateData.frontendFramework !== 'Aucun (API seulement)') {
    generator.log(chalk.white("  Frontend: http://localhost:3000"));
  }

  if (templateData.includeAuth) {
    generator.log(chalk.white("  Swagger/API: http://localhost:8080/swagger-ui.html"));
  }

  // Documentation
  generator.log(chalk.blue("\nüìö DOCUMENTATION ET AIDE:"));
  generator.log(chalk.gray("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"));
  generator.log(chalk.white("  Documentation: README.md"));
  generator.log(chalk.white("  Aide suppl√©mentaire: https://github.com/tky0065/spring-fullstack-speed/wiki"));

  generator.log(chalk.gray("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"));
  generator.log(chalk.green("\nBon d√©veloppement avec Spring-Fullstack-Speed! üöÄ"));
}

/**
 * Affiche les v√©rifications post-g√©n√©ration et conseils pour le projet g√©n√©r√©
 * @param generator R√©f√©rence au g√©n√©rateur
 * @param templateData Donn√©es du template utilis√©
 */
export async function postGenerationChecksAndAdvice(generator: any, templateData: any): Promise<void> {
  // V√©rifier l'int√©grit√© du projet
  const integrityResult = verifyProjectIntegrity(generator, templateData);

  // V√©rifier les versions des outils
  const toolsResult = await checkToolVersions(generator);

  // Tenter d'installer les d√©pendances frontend si n√©cessaire
  let npmInstallResult: { success: boolean, error?: string } = { success: true };
  if (templateData.frontendFramework !== 'Aucun (API seulement)') {
    npmInstallResult = await installFrontendDependencies(generator, templateData);
    if (!npmInstallResult.success && npmInstallResult.error) {
      integrityResult.warnings.push(npmInstallResult.error);
    }
  }

  // Afficher les r√©sultats et conseils
  toolsResult.messages.forEach(message => generator.log(message));

  // Afficher le r√©sum√© final et instructions
  displayFinalInstructions(generator, templateData, integrityResult);
}
