package <%= packageName %>.service;

import <%= packageName %>.dto.WebSocketMessageDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Service pour gérer les communications WebSocket.
 */
@Service
public class WebSocketService {

    private final Logger log = LoggerFactory.getLogger(WebSocketService.class);
    private final SimpMessagingTemplate messagingTemplate;

    // Statistiques des messages
    private final AtomicInteger messageCount = new AtomicInteger(0);
    private final ConcurrentHashMap<String, AtomicInteger> messageTypeCount = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, Instant> lastUserActivity = new ConcurrentHashMap<>();

    public WebSocketService(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    /**
     * Traite un message WebSocket avant son envoi.
     *
     * @param message le message à traiter
     * @return le message traité
     */
    public WebSocketMessageDTO processMessage(WebSocketMessageDTO message) {
        // Vérifier et définir le timestamp si nécessaire
        if (message.getTimestamp() == null) {
            message.setTimestamp(Instant.now());
        }

        // Traiter le type de message
        if (message.getType() == null) {
            message.setType("MESSAGE");
        }

        // Mettre à jour les statistiques
        messageCount.incrementAndGet();
        messageTypeCount.computeIfAbsent(message.getType(), k -> new AtomicInteger()).incrementAndGet();

        // Enregistrer l'activité de l'utilisateur
        if (message.getFrom() != null) {
            lastUserActivity.put(message.getFrom(), Instant.now());
        }

        return message;
    }

    /**
     * Envoie un message à tous les clients connectés au topic spécifié.
     *
     * @param topic le topic cible
     * @param message le message à envoyer
     */
    public void broadcastToTopic(String topic, WebSocketMessageDTO message) {
        log.debug("Broadcasting message to topic {}: {}", topic, message);
        messagingTemplate.convertAndSend(topic, processMessage(message));
    }

    /**
     * Envoie un message privé à un utilisateur spécifique.
     *
     * @param userId l'identifiant de l'utilisateur destinataire
     * @param message le message à envoyer
     */
    public void sendToUser(String userId, WebSocketMessageDTO message) {
        log.debug("Sending message to user {}: {}", userId, message);
        messagingTemplate.convertAndSendToUser(
            userId,
            "/queue/private",
            processMessage(message)
        );
    }

    /**
     * Envoie une notification système à tous les clients.
     *
     * @param content le contenu de la notification
     */
    public void sendSystemNotification(String content) {
        WebSocketMessageDTO notification = new WebSocketMessageDTO();
        notification.setFrom("system");
        notification.setContent(content);
        notification.setType("NOTIFICATION");
        notification.setTimestamp(Instant.now());

        broadcastToTopic("/topic/notifications", notification);
    }

    /**
     * Récupère les statistiques des messages WebSocket.
     *
     * @return une map contenant les statistiques
     */
    public Map<String, Object> getWebSocketStats() {
        Map<String, Object> stats = new ConcurrentHashMap<>();
        stats.put("messageCount", messageCount.get());
        stats.put("messageTypeCount", messageTypeCount);
        stats.put("activeUsers", lastUserActivity.size());
        return stats;
    }

    /**
     * Vérifie si un utilisateur est actuellement actif.
     *
     * @param userId l'identifiant de l'utilisateur
     * @return true si l'utilisateur est actif, false sinon
     */
    public boolean isUserActive(String userId) {
        Instant lastActivity = lastUserActivity.get(userId);
        if (lastActivity == null) {
            return false;
        }
        // Considérer un utilisateur comme actif s'il a eu une activité dans les 5 minutes
        return lastActivity.isAfter(Instant.now().minusSeconds(300));
    }
}
