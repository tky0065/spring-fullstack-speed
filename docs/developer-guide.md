# Guide du Développeur Spring-Fullstack-Speed

Ce guide est destiné aux développeurs qui souhaitent contribuer au projet Spring-Fullstack-Speed ou étendre ses fonctionnalités. Il fournit des informations détaillées sur l'architecture, les conventions de code, les tests et les meilleures pratiques.

## Table des matières

1. [Architecture du projet](#architecture-du-projet)
2. [Organisation des fichiers](#organisation-des-fichiers)
3. [Extension des générateurs](#extension-des-générateurs)
4. [Création de templates](#création-de-templates)
5. [Système de plugins](#système-de-plugins)
6. [Tests et qualité de code](#tests-et-qualité-de-code)
7. [Workflow de développement](#workflow-de-développement)
8. [Guide de contribution](#guide-de-contribution)

## Architecture du projet

Spring-Fullstack-Speed (`sfs`) est un générateur de code basé sur Yeoman qui utilise une architecture modulaire à plusieurs niveaux :

```
┌───────────────────────────────────┐
│            CLI Interface          │
└────────────────┬──────────────────┘
                 │
┌────────────────▼──────────────────┐
│         Base Generator            │
└────────────────┬──────────────────┘
                 │
      ┌──────────┴───────────┐
      │                      │
┌─────▼────┐    ┌───────────▼─────────┐
│Generators│    │Template Engine       │
└─────┬────┘    └───────────┬─────────┘
      │                     │
┌─────▼─────────────────────▼─────────┐
│          File Generation            │
└───────────────────────────────────┬─┘
                 │
┌────────────────▼──────────────────┐
│       Plugin System               │
└───────────────────────────────────┘
```

### Principes fondamentaux

1. **Séparation des préoccupations** : Chaque générateur a une responsabilité unique
2. **Extensibilité** : Le système de plugins permet d'étendre les fonctionnalités
3. **Réutilisabilité** : Les générateurs de base fournissent des fonctionnalités communes
4. **Testabilité** : Chaque composant est conçu pour être facilement testable

## Organisation des fichiers

Le projet est organisé selon la structure suivante :

```
spring-fullstack-speed/
├── generators/          # Cœur du générateur
│   ├── __tests__/       # Tests des générateurs
│   ├── add/             # Générateur d'ajouts de composants
│   ├── app/             # Générateur principal
│   ├── crud/            # Générateur CRUD
│   ├── entity/          # Générateur d'entités
│   └── ...              # Autres générateurs spécifiques
├── docs/                # Documentation
├── scripts/             # Scripts utilitaires
└── utils/               # Classes utilitaires
```

### Convention de nommage

- Les fichiers de générateur principal sont nommés `index.ts`
- Les fichiers de tests sont suffixés par `.test.ts`
- Les templates utilisent l'extension `.ejs` pour les templates EJS

## Extension des générateurs

Spring-Fullstack-Speed est conçu pour être facilement extensible. Vous pouvez étendre les générateurs existants de deux façons principales :

### 1. Par héritage

```typescript
import { EntityGenerator } from 'spring-fullstack-speed';

export default class CustomEntityGenerator extends EntityGenerator {
  constructor(args, opts) {
    super(args, opts);
    // Personnalisation du constructeur
  }
  
  // Surcharge des méthodes
  async writing() {
    // Appel de la méthode parente
    await super.writing();
    
    // Logique personnalisée
    this.renderTemplate(
      this.templatePath('custom-template.ejs'),
      this.destinationPath('custom-output.java'),
      this.context
    );
  }
}
```

### 2. Par composition

```typescript
import { BaseGenerator } from 'spring-fullstack-speed';

export default class CompositeGenerator extends BaseGenerator {
  constructor(args, opts) {
    super(args, opts);
  }
  
  async initializing() {
    // Utiliser un autre générateur en composition
    await this.composeWith(require.resolve('../entity'), {
      arguments: [this.options.name],
      context: this.context
    });
  }
  
  // Autres méthodes...
}
```

## Création de templates

Les templates sont au cœur du système de génération de code. Spring-Fullstack-Speed utilise EJS comme moteur de template.

### Structure d'un template typique

```ejs
<%# src/main/java/<%= packagePath %>/<%= entityName %>.java %>
package <%= packageName %>;

<% if (useJPA) { %>
import javax.persistence.*;
<% } %>

/**
 * <%= entityName %> entity.
 * Generated by Spring-Fullstack-Speed
 */
<% if (useJPA) { %>@Entity<% } %>
public class <%= entityName %> {
    <% fields.forEach(function(field) { %>
    private <%= field.type %> <%= field.name %>;
    <% }); %>
    
    // Constructors, getters and setters...
}
```

### Utilisation des helpers

```ejs
<%# Utilisation d'un helper pour la mise en forme %>
<%= formatClassName(name) %> extends <%= baseClass %> {
    <%= includeIf('common/fields.ejs', { fields: fields }) %>
}
```

## Système de plugins

Spring-Fullstack-Speed permet l'extension via un système de plugins. Un plugin est un module Node.js qui respecte une structure spécifique.

### Structure d'un plugin

```
sfs-plugin-example/
├── package.json
├── index.js
└── generators/
    └── custom/
        ├── index.js
        └── templates/
```

### Exemple de définition de plugin

```javascript
// index.js du plugin
module.exports = {
  name: 'sfs-plugin-example',
  description: 'Plugin exemple pour Spring-Fullstack-Speed',
  version: '1.0.0',
  
  // Hooks pour s'intégrer aux événements du générateur
  hooks: {
    'entity:created': function(generator, entityName) {
      // Action à exécuter quand une entité est créée
      console.log(`Plugin notified: Entity ${entityName} was created`);
    }
  },
  
  // Générateurs supplémentaires fournis par le plugin
  generators: {
    'custom-entity': require.resolve('./generators/custom-entity')
  }
};
```

### Installation et utilisation d'un plugin

```bash
# Installation
npm install sfs-plugin-example --save-dev

# Utilisation
sfs custom-entity MyEntity
```

## Tests et qualité de code

Spring-Fullstack-Speed utilise Jest pour les tests. Tous les générateurs doivent être accompagnés de tests.

### Structure des tests

```typescript
import { run } from 'yeoman-test';
import * as assert from 'yeoman-assert';
import * as path from 'path';

describe('entity:generator', () => {
  it('should generate an entity file', async () => {
    // Préparer
    const entityName = 'TestEntity';
    
    // Exécuter
    await run(path.join(__dirname, '../entity'))
      .withArguments([entityName])
      .withOptions({ skipInstall: true });
      
    // Vérifier
    assert.file('src/main/java/com/example/TestEntity.java');
    assert.fileContent(
      'src/main/java/com/example/TestEntity.java',
      'public class TestEntity'
    );
  });
});
```

### Exécution des tests

```bash
# Exécuter tous les tests
npm test

# Exécuter un test spécifique
npm test -- -t "entity:generator"

# Exécuter avec couverture de code
npm run test:coverage
```

## Workflow de développement

1. **Création d'une branche**
   ```bash
   git checkout -b feature/ma-nouvelle-fonctionnalite
   ```

2. **Développement et tests**
   ```bash
   # Développer la fonctionnalité
   # Écrire les tests
   npm test
   ```

3. **Construction**
   ```bash
   npm run build
   ```

4. **Test manuel**
   ```bash
   # Lier le package localement
   npm link
   
   # Créer un projet de test
   mkdir test-project && cd test-project
   sfs app my-test-app
   ```

5. **Soumission du code**
   ```bash
   git add .
   git commit -m "feat: ajout d'une nouvelle fonctionnalité"
   git push origin feature/ma-nouvelle-fonctionnalite
   ```

## Guide de contribution

1. **Fork** du projet sur GitHub
2. **Clone** de votre fork
   ```bash
   git clone https://github.com/votre-nom/spring-fullstack-speed.git
   ```
3. **Installation** des dépendances
   ```bash
   cd spring-fullstack-speed
   npm install
   ```
4. **Créez une branche** pour votre contribution
   ```bash
   git checkout -b feature/ma-contribution
   ```
5. **Implémentez** votre contribution et ajoutez des tests
6. **Vérifiez** que tous les tests passent
   ```bash
   npm test
   ```
7. **Soumettez** une Pull Request

### Conventions de code

- Suivre les règles ESLint configurées
- Écrire des tests pour toutes les nouvelles fonctionnalités
- Documenter le code avec JSDoc
- Respecter la convention de nommage
- Utiliser TypeScript pour tout nouveau code

### Cycle de vie de contribution

1. **Issue** - Créer ou identifier une issue à résoudre
2. **Discussion** - Discuter de l'approche de résolution
3. **Implémentation** - Coder la solution
4. **Tests** - Ajouter des tests pour la nouvelle fonctionnalité
5. **Documentation** - Mettre à jour la documentation
6. **Pull Request** - Soumettre le code pour revue
7. **Revue** - Répondre aux commentaires et apporter des corrections
8. **Fusion** - Une fois approuvé, le code est fusionné

## Ressources supplémentaires

- [Documentation de l'API interne](./api-interne.md)
- [Guide du débutant](./getting-started.md)
- [Guide d'architecture](./architecture.md)
- [Guide des tests](./tests.md)

---

Ce guide est en constante évolution. N'hésitez pas à proposer des améliorations ou à signaler des erreurs.
